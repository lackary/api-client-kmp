name: Build and Test

on:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/**'
      - 'composeApp/**'
      - 'iosApp/**'
      - 'gradle/**'
      - 'modules/**'
      - 'build.gradle.kts'
      - 'settings.gradle.kts'
      - 'package.json'

  pull_request:
    branches:
      - '*'
    paths:
      - '.github/workflows/**'
      - 'composeApp/**'
      - 'iosApp/**'
      - 'gradle/**'
      - 'modules/**'
      - 'build.gradle.kts'
      - 'settings.gradle.kts'
      - 'package.json'

  workflow_dispatch:
    inputs:
      enable_kotlin_daemon:
        description: 'Enable Kotlin/Native Daemon for build'
        type: boolean
        required: false
        default: false

      run_with_stacktrace:
        description: 'Run Gradle with --stacktrace'
        type: boolean
        required: false
        default: false

      run_with_info:
        description: 'Run Gradle with --info'
        type: boolean
        required: false
        default: false

      run_with_debug:
        description: 'Run Gradle with --debug'
        type: boolean
        required: false
        default: false

jobs:
  build-and-test:
    name: build and test
    runs-on: macos-latest
    permissions:
      contents: read
    outputs: # Optional, if subsequent jobs need to know if the tests were successful
      test_outcome: ${{ steps.run_tests.outcome }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

#      - name: Cache Gradle packages
#        uses: actions/cache@v3
#        with:
#          path: |
#            ~/.gradle/caches
#            ~/.gradle/wrapper
#          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
#          restore-keys: |
#            ${{ runner.os }}-gradle-

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Create Dynamic Secrets XConfig File
        working-directory: './iosApp/Configuration'
        # Create your .xconfig file (the name must match what Xcode expects to read)
        # Write GIDClientID (corresponding to CLIENT_ID)
        # Write CFBundleURLSchemes (corresponding to REVERSED_CLIENT_ID)
        run: |
          XCONFIG_DEBUG_FILENAME="Secrets-Debug.xconfig"
          XCONFIG_RELEASE_FILENAME="Secrets-Release.xconfig"

          echo "======================================"
          echo "Creating ${XCONFIG_DEBUG_FILENAME} in CI..."
          echo "Creating ${XCONFIG_RELEASE_FILENAME} in CI..."
          
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" > "${XCONFIG_DEBUG_FILENAME}"
          echo "REVERSE_CLIENT_ID=${{ secrets.GOOGLE_REVERSED_CLIENT_ID }}" >> "${XCONFIG_DEBUG_FILENAME}"
          echo "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" > "${XCONFIG_RELEASE_FILENAME}"
          echo "REVERSE_CLIENT_ID=${{ secrets.GOOGLE_REVERSED_CLIENT_ID }}" >> "${XCONFIG_RELEASE_FILENAME}"
          
          echo "======================================"

      - name: Resolve Swift Package Manager Dependencies
        working-directory: './iosApp'
        # Execute a basic Xcode build command to download, parse, and prepare SPM dependencies.
        # Use '-target' or '-scheme' to specify your main application target/scheme.
        # Typically, the target/scheme name is the same as your iOS application folder name (e.g., iosApp).
        # The '-resolvePackageDependencies' command instructs Xcode to download all SPM dependencies.
        # This command makes Xcode download all SPM dependencies.
        # Perform a Clean Build targeting the iOS simulator.
        # This step generates the build output path for SPM dependencies.
        run: |
          echo "Resolving SPM dependencies via xcodebuild..."
          xcodebuild -resolvePackageDependencies -project "iosApp.xcodeproj" -scheme "iosApp"
          
          echo "2. Building iOS Target to set environment variables..."
          xcodebuild clean build \
              -project "iosApp.xcodeproj" \
              -scheme "iosApp" \
              -configuration "Debug" \
              -sdk iphonesimulator \
              -destination "platform=iOS Simulator,name=iPhone 16 Pro Max" 
          
          echo "SPM dependencies built and output path set."

      - name: Build and test entire project
        env:
          UNSPLASH_API_KEY: ${{ secrets.UNSPLASH_API_KEY }}
        # -Pskip.tests
        # Because the test APIs of Compose Multiplatform is still Experimental.
        run: ./gradlew build -Pskip.tests -Pandroid.useAndroidX=true -Porg.gradle.caching=true -Dorg.gradle.jvmargs=-Xmx8192M ${{ inputs.run_with_stacktrace && '--stacktrace' || '' }} ${{ inputs.run_with_info && '--info' || '' }} ${{ inputs.run_with_debug && '--debug' || '' }} ${{ inputs.enable_kotlin_daemon && '-Pkotlin.native.enableDaemon=true' || '' }}

      - name: Upload Test Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports # Name of the Artifact
          path: '**/build/test-results/**/*.xml'
          retention-days: 1 # Optional, set the artifact retention time

#      - name: Test Reporter
#        uses: dorny/test-reporter@v1
#        if: always() # success() || failure() # Run on success or failure
#        with:
#          name: Test Results
#          path: '**/build/test-results/**/*.xml' # Path to JUnit XML reports
#          reporter: java-junit # Select based on report format
#          token: ${{secrets.GITHUB_TOKEN}}

  report-test-results:
    name: report test results
    runs-on: ubuntu-latest # The report job can use a different OS if needed
    needs: build-and-test # Ensures this runs after build-and-test is complete
#    permissions: # Ensures the report job has permissions to create check runs
#      checks: write
    if: always() # Always run the report job, even if build-and-test fails (dorny/test-reporter can report failures)
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Test Reports
        uses: actions/download-artifact@v4
        with:
          name: test-reports # Same as the artifact name used for uploading
          path: downloaded-test-reports # Download to a specified directory

      - name: Test Reporter
        uses: dorny/test-reporter@v1
        with:
          name: Test Results
          path: 'downloaded-test-reports/**/*.xml' # Point to the downloaded report path
          reporter: java-junit
          token: ${{ secrets.GITHUB_TOKEN }} # Point to the downloaded report path
          # fail-on-error: true # Set as needed; if build-and-test has already failed, you might not need this to fail again
